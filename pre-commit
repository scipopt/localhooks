#!/bin/sh
#
# An extended example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.

if git rev-parse --verify HEAD >/dev/null 2>&1
then
  against=HEAD
else
  # Initial commit: diff against an empty tree object
  against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
fi

# If you want to allow non-ascii filenames set this variable to true.
allownonascii=$(git config hooks.allownonascii)
sizelimit=52428800

# Cross platform projects tend to avoid non-ascii filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
  # Note that the use of brackets around a tr range is ok here, (it's
  # even required, for portability to Solaris 10's /usr/bin/tr), since
  # the square bracket bytes happen to fall in the designated range.
  test "$(git diff --cached --name-only --diff-filter=A -z $against |
    LC_ALL=C tr -d '[ -~]\0')"
    then
      echo "Attempt to add a non-ascii file name. Please choose a different name."
      exit 1
fi

# this checks that no unimportant whitespace changes are committed
whitespace=$(git diff-index --check --cached $against --)
echo "> Checking for whitespace errors."
if [ "${whitespace}" != "" ]; then
  echo "Your staged changes contain whitespace errors, please fix before committing."
  exit 1
fi

# check for `#if 0` in the code
ifzeros=$(git diff --cached HEAD *.c *.h *.cpp *.hpp *.sh | grep "^+" | grep "#if[[:space:]]\+0")
echo "> Checking occurences of '#if 0'."
if [ "${ifzeros}" != "" ]; then
  echo "Your staged changes contain '#if 0'. Please use '#ifdef SCIP_DISABLED_CODE' along with an explanatory comment instead."
  exit 1
fi

# check the filesize of each file stays below sizelimit
# list new or modified files newfiles=$(git diff --staged --name-only )
currdir="$(pwd)"
for file in $(git diff --cached --name-only | sort | uniq); do
  filesize=$(du -b ${currdir}/${file} | awk '{print $1}')
  if [ "${size}" -ge "${sizelimit}" ]; then
    echo "hard size limit (${sizelimit}) exceeded: ${file} (${size} bytes)"
    exit 1
  fi
done

echo "All fine, thank you."
