#!/bin/bash
# hooks/update
#
# Please install the local hooks from https://git.zib.de/optimization/localhooks/
# to check the style locally on every commit.
#
# Description from https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks#Server-Side-Hooks
#
# The update script is very similar to the pre-receive script, except that it’s run once
# for each branch the pusher is trying to update. If the pusher is trying to push to
# multiple branches, pre-receive runs only once, whereas update runs once per branch
# they’re pushing to. Instead of reading from stdin, this script takes three arguments:
# the name of the reference (branch), the SHA-1 that reference pointed to before the push,
# and the SHA-1 the user is trying to push. If the update script exits non-zero, only that
# reference is rejected; other references can still be updated.

refname=$1 # name of ref that is being updated
oldrev=$2 # old object name that ref pointed to before
newrev=$3 # new object name that ref should point to
nullsha="0000000000000000000000000000000000000000"
emptysha=$(git hash-object -t tree /dev/null) # SHA1: "4b825dc642cb6eb9a060e54bf8d69288fbee4904"

echo "Enforcing policies for revision ${refname}:"

# -------------------------------
# Get the list of all the commits
# -------------------------------

# exit if a branch is about to be deleted
if [ "${newrev}" == "${nullsha}" ]; then
  exit 0
fi

# Set oldrev properly if the is branch created
if [ "${oldrev}" = "${nullsha}" ]; then
   oldrev=$emptysha
fi

checksince="--since=2020-04-27"
sizelimit=52428800

# branch labels are updated *after* the hook ran successfully,
# so get all commits reachable from newrev (that are newer than a certain date),
# that are not reachable from any yet known ref (branch) labels
span=$(git rev-list ${newrev} ${checksince} --not --all)

# ----------------------------------------
# Iterate over all new commits in the push
# ----------------------------------------

refuse=false
for sha1 in ${span}; do
  dateint=$(git log "${sha1}" --pretty=%cd -n 1 --date=format:"%Y%m%d" )
  # don't check commits from before 2020
  if [ "${dateint}" -lt '20200427' ]; then
    continue
  fi

  # don't check merge commits
  # only merge commits have more than one parent
  nparents=$(git cat-file -p ${sha1} |grep parent|wc -l)
  if [ "${nparents}" != 1 ]; then
    continue
  fi

  # check the filesize of each file stays below sizelimit
  # list new or modified files
  modifiedfiles=$(git show --pretty="format:" --name-only --diff-filter=ACMRT ${sha1} )

  for file in ${modifiedfiles}; do
    size=$(git cat-file -s "${sha1}:${file}")
    if [[ -z $size ]]; then
        size=0;
    fi

    if [ "${size}" -gt "${sizelimit}" ]
    then
      echo "${sha1} hard size limit (${sizelimit}) exceeded: ${file} (${size} bytes)"
      refuse=true
    fi
  done

  # check commit message
  commitmessage=$(git log --format=%B -n 1 ${sha1})
  commitfirstline=$(echo "${commitmessage}" | head -n 1)

  # don't check revert commits
  if [[ "${commitfirstline}" == Revert* ]]; then
    continue
  fi

  # if commitmessage has 2 or more lines, make sure the second line is empty
  if [ $(echo "${commitmessage}" | wc -l) -ge 2 ]; then
    if [ "$(echo "${commitmessage}" | head -n 2 | tail -n 1)" != "" ]; then
      echo "${sha1} bad commit message; second line is not blank"
      refuse=true
    fi
  fi

  # check length of commit description lines
  while IFS= read -r line; do
    if [ 75 -lt $(echo "${line}" | wc -c) ]; then
      echo "${sha1} bad commit message; header or description lines are too long (max 75 chars per line)"
      refuse=true
      break
    fi
  done <<< "${commitmessage}"

  # check for whitespace errors in commit
  whitespace=$(exec git diff --check ${sha1}^ ${sha1} *.c *.h *.cpp *.hpp *.sh)
  if [ "${whitespace}" != "" ]; then
    echo "${sha1} contains whitespace errors."
    refuse=true
  fi

  # check for `#if 0` in the code
  ifzeros=$(git diff ${sha1}^ ${sha1} *.c *.h *.cpp *.hpp *.sh | grep "^+" | grep "#if[[:space:]]\+0")
  if [ "${ifzeros}" != "" ]; then
    echo "Your staged changes contain '#if 0'. Please use '#ifdef SCIP_DISABLED_CODE' along with an explanatory comment instead."
    refuse=true
  fi
done

if [ "${refuse}" == true ]; then
  echo "Found errors, please fix them before pushing."
  exit 1
else
  echo "All good, thank you!"
fi
